# -*- coding: utf-8 -*-
"""Final_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GOOtOnkrROe0SbOiR1H3JeJF2F84X3YI
"""

import pandas as pd
import requests
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import train_test_split
from bs4 import BeautifulSoup

url_main = 'https://fbref.com/en/comps/9/2022-2023/2022-2023-Premier-League-Stats'
url_last = 'https://fbref.com/en/comps/9/2021-2022/2021-2022-Premier-League-Stats'

main_tables = pd.read_html(url_main)
last_tables = pd.read_html(url_last)

# Extract the desired table
premier_league_stats = main_tables[0]
premier_league_last_stats = last_tables[0]


# Filter the data for the selected teams and features
selected_teams = ['Arsenal', 'Chelsea', 'Liverpool', 'Manchester City', 'Manchester Utd', 'Tottenham']
selected_stats = premier_league_stats[premier_league_stats['Squad'].isin(selected_teams)]
selected_stats_last = premier_league_last_stats[premier_league_last_stats['Squad'].isin(selected_teams)]
team_stats = selected_stats[['Squad', 'W', 'D', 'L', 'GF', 'GA', 'Pts','Rk']]
team_stats_last = selected_stats_last[['Squad', 'W', 'D', 'L', 'GF', 'GA', 'Pts','Rk']]
team_stats.columns = ['Team','W','D','L', 'GF','GA', 'Points','Rank']
team_stats_last.columns = ['Team','W','D','L', 'GF','GA', 'Points','Rank']
# Display the table
print("2022-2023")
print(team_stats)
print("2021-2022")
print(team_stats_last)

combined_stats = pd.merge(team_stats, team_stats_last, on='Team', suffixes=('_2022-2023', '_2021-2022'))

# Create bar plots for selected statistics
ax = combined_stats.plot(kind='bar', x='Team', y=['W_2022-2023', 'W_2021-2022','D_2022-2023','D_2021-2022', 'L_2022-2023','L_2021-2022'],
                         figsize=(10, 6))
ax.set_title('Premier League: Wins, Draws, and Losses Comparison')
ax.set_xlabel('Team')
ax.set_ylabel('Count')
ax.set_xticklabels(combined_stats['Team'], rotation=45)
ax.legend(['Wins 2022-2023','Wins 2021-2022', 'Draws 2022-2023','Draws 2021-2022', 'Losses 2022-2023','Losses 2021-2022'])
plt.show()

ax = combined_stats.plot(kind='bar', x='Team', y=['GF_2022-2023', 'GA_2022-2023', 'GF_2021-2022', 'GA_2021-2022'],
                         figsize=(10, 6))
ax.set_title('Premier League: Goals For and Goals Against Comparison')
ax.set_xlabel('Team')
ax.set_ylabel('Count')
ax.set_xticklabels(combined_stats['Team'], rotation=45)
ax.legend(['Goals For 2022-2023', 'Goals Against 2022-2023', 'Goals For 2021-2022', 'Goals Against 2021-2022'])
plt.show()

ax = combined_stats.plot(kind='bar', x='Team', y=['Points_2022-2023', 'Points_2021-2022'], figsize=(10, 6))
ax.set_title('Premier League: Points Comparison')
ax.set_xlabel('Team')
ax.set_ylabel('Points')
ax.set_xticklabels(combined_stats['Team'], rotation=45)
ax.legend(['Points 2022-2023', 'Points 2021-2022'])
plt.show()

ax = combined_stats.plot(kind='bar', x='Team', y=['Rank_2022-2023', 'Rank_2021-2022'], figsize=(10, 6))
ax.set_title('Premier League: Rank Comparison')
ax.set_xlabel('Team')
ax.set_ylabel('Rank')
ax.set_xticklabels(combined_stats['Team'], rotation=45)
ax.legend(['Rank 2022-2023', 'Rank 2021-2022'])
plt.show()

# Read the Premier League home/away stats
home_away_stats = main_tables [1]

# Filter the data for the six teams
team_stats = home_away_stats[home_away_stats[('Unnamed: 1_level_0', 'Squad')].isin(selected_teams)]

# Select relevant columns for analysis
selected_columns = [('Unnamed: 1_level_0', 'Squad'), ('Home', 'W'), ('Home', 'D'), ('Home', 'L'),
                    ('Away', 'W'), ('Away', 'D'), ('Away', 'L')]

team_stats = team_stats[selected_columns]
team_stats.columns = ['Squad', 'W_home', 'D_home', 'L_home', 'W_away', 'D_away', 'L_away']
team_stats.set_index('Squad', inplace=True)

# Plotting the analysis
fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(10, 10))

team_stats[['W_home', 'D_home', 'L_home']].plot(ax=axes[0], kind='bar', stacked=True, colormap='tab10')
axes[0].set_title('Home Game Analysis')
axes[0].set_xlabel('Team')
axes[0].set_ylabel('Count')
axes[0].legend(loc='upper right')

team_stats[['W_away', 'D_away', 'L_away']].plot(ax=axes[1], kind='bar', stacked=True, colormap='tab10')
axes[1].set_title('Away Game Analysis')
axes[1].set_xlabel('Team')
axes[1].set_ylabel('Count')
axes[1].legend(loc='upper right')

# Adjusting subplots layout
plt.tight_layout()
plt.show()

shooting_stats_table = main_tables[8]

# Select the relevant columns and rows for the six teams
team_shooting_table = shooting_stats_table[shooting_stats_table[('Unnamed: 0_level_0', 'Squad')].isin(selected_teams)][[('Unnamed: 0_level_0', 'Squad'), ('Standard', 'SoT%')]].reset_index(drop=True)

# Extract the SoT% data from the table
sot_percentages = team_shooting_table[('Standard', 'SoT%')].astype(float)
labels = team_shooting_table[('Unnamed: 0_level_0', 'Squad')]

# Create the bar plot
plt.figure(figsize=(10, 8))
plt.bar(labels, sot_percentages)
plt.xlabel('Team')
plt.ylabel('Shots on Target Percentage (SoT%)')
plt.title('Shots on Target Percentage for Premier League Teams')
plt.tight_layout()
plt.show()

# Extract the possession data for the six teams
possession_data = main_tables[18].copy()
possession_data.columns = possession_data.columns.droplevel(0)
possession_data = possession_data[possession_data['Squad'].isin(selected_teams)]

# Select the relevant columns
possession_data = possession_data[['Squad', 'Def Pen', 'Def 3rd', 'Mid 3rd', 'Att 3rd', 'Att Pen']]

# Calculate the proportions
total_possessions = possession_data.sum(axis=1)
defensive = possession_data['Def Pen'] + possession_data['Def 3rd']
midfield = possession_data['Mid 3rd']
attacking = possession_data['Att 3rd'] + possession_data['Att Pen']
proportions = possession_data[['Squad']].copy()
proportions['Defensive'] = defensive / total_possessions
proportions['Midfield'] = midfield / total_possessions
proportions['Attacking'] = attacking / total_possessions

# Create the bar plot
proportions.set_index('Squad').plot(kind='bar', stacked=True)
plt.xlabel('Team')
plt.ylabel('Proportion')
plt.title('Playing Style of the Six Teams')
plt.legend(['Defensive', 'Midfield', 'Attacking'])
plt.show()

team_urls = {
    'Arsenal': 'https://fbref.com/en/squads/18bb7c10/2022-2023/Arsenal-Stats',
    'Chelsea': 'https://fbref.com/en/squads/cff3d9bb/2022-2023/Chelsea-Stats',
    'Liverpool': 'https://fbref.com/en/squads/822bd0ba/2022-2023/Liverpool-Stats',
    'Manchester City': 'https://fbref.com/en/squads/b8fd03ef/2022-2023/Manchester-City-Stats',
    'Manchester United': 'https://fbref.com/en/squads/19538871/2022-2023/Manchester-United-Stats',
    'Tottenham': 'https://fbref.com/en/squads/361ca564/2022-2023/Tottenham-Hotspur-Stats'
}

# Function to analyze referee statistics for a given URL
def analyze_referee_stats(url):
    tables = pd.read_html(url)
    df = tables[1]
    premier_league_table = df[df["Comp"] == "Premier League"]
    referees = premier_league_table["Referee"]
    results = premier_league_table["Result"]

    referee_stats = {}
    for referee, result in zip(referees, results):
        if referee in referee_stats:
            if result == "W":
                referee_stats[referee]["Wins"] += 1
            elif result == "L":
                referee_stats[referee]["Losses"] += 1
        else:
            if result == "W":
                referee_stats[referee] = {"Wins": 1, "Losses": 0}
            elif result == "L":
                referee_stats[referee] = {"Wins": 0, "Losses": 1}

    return referee_stats

# Dictionary to store referee stats for each team
team_referee_stats = {}

# Analyze referee stats for each team
for team, url in team_urls.items():
    team_referee_stats[team] = analyze_referee_stats(url)

# Plotting the referee statistics

plt.figure(figsize=(12, 8))
colors = ['b', 'g', 'r', 'c', 'm','y']  # Colors for each team

for i, (team, stats) in enumerate(team_referee_stats.items()):
    referees = []
    wins = []
    losses = []

    for referee, stat in stats.items():
        referees.append(referee)
        wins.append(stat['Wins'])
        losses.append(stat['Losses'])

    x = range(len(referees))

    # Scatter plot for wins
    plt.scatter(x, wins, c=colors[i], label=f'{team} - Wins', marker='o')

    # Scatter plot for losses
    plt.scatter(x, losses, c=colors[i], label=f'{team} - Losses', marker='x')

plt.xlabel('Referee')
plt.ylabel('Count')
plt.title('Referee Statistics Comparison')
plt.xticks(range(len(referees)), referees, rotation=90)
plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left')
plt.tight_layout()
plt.show()

df = []
# Loop through the team URLs
for team, url in team_urls.items():
    tables = pd.read_html(url)
    data = tables[1]

    # Add a new 'Team' column with the current team name
    data['Team'] = team

    df.append(data)

# Combine data for all teams
all_teams_data = pd.concat(df)

# Filter Premier League matches for all teams
premier_league_data = all_teams_data[all_teams_data['Comp'] == 'Premier League']

# Convert 'GF' and 'GA' columns to numeric
premier_league_data[['GF', 'GA']] = premier_league_data[['GF', 'GA']].apply(pd.to_numeric)

# Calculate Score Difference
premier_league_data['ScoreDiff'] = premier_league_data['GF'] - premier_league_data['GA']

# Add a column for game number
premier_league_data['WeekNumber'] = range(1, len(premier_league_data) + 1)

# Select relevant features
selected_features = ['Date','ScoreDiff','Team', 'WeekNumber', 'Opponent','Venue', 'GF', 'GA', 'xG', 'xGA', 'Poss', 'Formation', 'Captain', 'Referee']
premier_league_data = premier_league_data[selected_features]

# Print the combined data
print(premier_league_data)

# Define your URLs for shooting statistics
shooting_urls = {
    'Arsenal': 'https://fbref.com/en/squads/18bb7c10/2022-2023/matchlogs/all_comps/shooting/Arsenal-Match-Logs-All-Competitions',
    'Chelsea': 'https://fbref.com/en/squads/cff3d9bb/2022-2023/matchlogs/all_comps/shooting/Chelsea-Match-Logs-All-Competitions',
    'Liverpool': 'https://fbref.com/en/squads/822bd0ba/2022-2023/matchlogs/all_comps/shooting/Liverpool-Match-Logs-All-Competitions',
    'Manchester City': 'https://fbref.com/en/squads/b8fd03ef/2022-2023/matchlogs/all_comps/shooting/Manchester-City-Match-Logs-All-Competitions',
    'Manchester United': 'https://fbref.com/en/squads/19538871/2022-2023/matchlogs/all_comps/shooting/Manchester-United-Match-Logs-All-Competitions',
    'Tottenham': 'https://fbref.com/en/squads/361ca564/2022-2023/matchlogs/all_comps/shooting/Tottenham-Hotspur-Match-Logs-All-Competitions'
}

# Define your URLs for possession statistics
possession_urls = {
    'Arsenal': 'https://fbref.com/en/squads/18bb7c10/2022-2023/matchlogs/all_comps/possession/Arsenal-Match-Logs-All-Competitions',
    'Chelsea': 'https://fbref.com/en/squads/cff3d9bb/2022-2023/matchlogs/all_comps/possession/Chelsea-Match-Logs-All-Competitions',
    'Liverpool': 'https://fbref.com/en/squads/822bd0ba/2022-2023/matchlogs/all_comps/possession/Liverpool-Match-Logs-All-Competitions',
    'Manchester City': 'https://fbref.com/en/squads/b8fd03ef/2022-2023/matchlogs/all_comps/possession/Manchester-City-Match-Logs-All-Competitions',
    'Manchester United': 'https://fbref.com/en/squads/19538871/2022-2023/matchlogs/all_comps/possession/Manchester-United-Match-Logs-All-Competitions',
    'Tottenham': 'https://fbref.com/en/squads/361ca564/2022-2023/matchlogs/all_comps/possession/Tottenham-Hotspur-Match-Logs-All-Competitions'
}

passing_urls = {
    'Arsenal': 'https://fbref.com/en/squads/18bb7c10/2022-2023/matchlogs/all_comps/passing/Arsenal-Match-Logs-All-Competitions',
    'Chelsea': 'https://fbref.com/en/squads/cff3d9bb/2022-2023/matchlogs/all_comps/passing/Chelsea-Match-Logs-All-Competitions',
    'Liverpool': 'https://fbref.com/en/squads/822bd0ba/2022-2023/matchlogs/all_comps/passing/Liverpool-Match-Logs-All-Competitions',
    'Manchester City':'https://fbref.com/en/squads/b8fd03ef/2022-2023/matchlogs/all_comps/passing/Manchester-City-Match-Logs-All-Competitions',
    'Manchester United':'https://fbref.com/en/squads/19538871/2022-2023/matchlogs/all_comps/passing/Manchester-United-Match-Logs-All-Competitions',
    'Tottenham': 'https://fbref.com/en/squads/361ca564/2022-2023/matchlogs/all_comps/passing/Tottenham-Hotspur-Match-Logs-All-Competitions'
}

goalkeeping_urls = {
    'Arsenal': 'https://fbref.com/en/squads/18bb7c10/2022-2023/matchlogs/all_comps/keeper/Arsenal-Match-Logs-All-Competitions',
    'Chelsea': 'https://fbref.com/en/squads/cff3d9bb/2022-2023/matchlogs/all_comps/keeper/Chelsea-Match-Logs-All-Competitions',
    'Liverpool': 'https://fbref.com/en/squads/822bd0ba/2022-2023/matchlogs/all_comps/keeper/Liverpool-Match-Logs-All-Competitions',
    'Manchester City':'https://fbref.com/en/squads/b8fd03ef/2022-2023/matchlogs/all_comps/keeper/Manchester-City-Match-Logs-All-Competitions',
    'Manchester United':'https://fbref.com/en/squads/19538871/2022-2023/matchlogs/all_comps/keeper/Manchester-United-Match-Logs-All-Competitions',
    'Tottenham': 'https://fbref.com/en/squads/361ca564/2022-2023/matchlogs/all_comps/keeper/Tottenham-Hotspur-Match-Logs-All-Competitions'
}


# Create an empty list to store the shooting DataFrames for each team
shooting_dfs = []

# Loop through the shooting URLs and scrape the data
for team, url in shooting_urls.items():
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    table = soup.find('table', {'class': 'stats_table'})
    df = pd.read_html(str(table), header=[0, 1], flavor='lxml')[0]
    shooting_dfs.append(df)

# Concatenate all shooting DataFrames into one
shooting_stats_df = pd.concat(shooting_dfs, keys=shooting_urls.keys())

# Create an empty list to store the possession DataFrames for each team
possession_dfs = []

# Loop through the possession URLs and scrape the data
for team, url in possession_urls.items():
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    table = soup.find('table', {'class': 'stats_table'})
    df = pd.read_html(str(table), header=[0, 1], flavor='lxml')[0]
    possession_dfs.append(df)

# Concatenate all possession DataFrames into one
possession_stats_df = pd.concat(possession_dfs, keys=possession_urls.keys())

passing_dfs = []

# Loop through the passsing URLs and scrape the data
for team, url in passing_urls.items():
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    table = soup.find('table', {'class': 'stats_table'})
    df = pd.read_html(str(table), header=[0, 1], flavor='lxml')[0]
    passing_dfs.append(df)

# Concatenate all goalkeeping DataFrames into one
passing_stats_df = pd.concat(passing_dfs, keys=passing_urls.keys())

goalkeeping_dfs = []

# Loop through the shooting URLs and scrape the data
for team, url in goalkeeping_urls.items():
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    table = soup.find('table', {'class': 'stats_table'})
    df = pd.read_html(str(table), header=[0, 1], flavor='lxml')[0]
    goalkeeping_dfs.append(df)

# Concatenate all shooting DataFrames into one
goalkeeping_stats_df = pd.concat(goalkeeping_dfs, keys=goalkeeping_urls.keys())



# Loop through the rows of the premier league data
for index, row in premier_league_data.iterrows():
    team = row['Team']
    opponent = row['Opponent']
    date = row['Date']

    if team == "Tottenham":
        matching_game_shooting = shooting_stats_df[('For Tottenham Hotspur', 'Opponent')].eq(opponent)
        matching_date_shooting= shooting_stats_df[('For Tottenham Hotspur', 'Date')].eq(date)
        matching_game_possession = possession_stats_df[('For Tottenham Hotspur', 'Opponent')].eq(opponent)
        matching_date_possession= possession_stats_df[('For Tottenham Hotspur', 'Date')].eq(date)
        matching_game_passing = passing_stats_df[('For Tottenham Hotspur', 'Opponent')].eq(opponent)
        matching_date_passing= passing_stats_df[('For Tottenham Hotspur', 'Date')].eq(date)
        matching_game_goalkeeping = goalkeeping_stats_df[('For Tottenham Hotspur', 'Opponent')].eq(opponent)
        matching_date_goalkeeping= goalkeeping_stats_df[('For Tottenham Hotspur', 'Date')].eq(date)
    else:

        matching_game_shooting = shooting_stats_df[('For ' + team, 'Opponent')].eq(opponent)
        matching_date_shooting = shooting_stats_df[('For ' + team, 'Date')].eq(date)
        matching_game_possession = possession_stats_df[('For ' + team, 'Opponent')].eq(opponent)
        matching_date_possession = possession_stats_df[('For ' + team, 'Date')].eq(date)
        matching_game_passing  = passing_stats_df[('For ' + team, 'Opponent')].eq(opponent)
        matching_date_passing = passing_stats_df[('For ' + team, 'Date')].eq(date)
        matching_game_goalkeeping  = goalkeeping_stats_df[('For ' + team, 'Opponent')].eq(opponent)
        matching_date_goalkeeping =goalkeeping_stats_df[('For ' + team, 'Date')].eq(date)

    matching_index_shooting = shooting_stats_df[matching_game_shooting & matching_date_shooting].index
    matching_index_possession = possession_stats_df[matching_game_possession & matching_date_possession].index
    matching_index_passing = passing_stats_df[matching_game_passing & matching_date_passing].index
    matching_index_goalkeeping = goalkeeping_stats_df[matching_game_goalkeeping & matching_date_goalkeeping].index

    if not matching_index_shooting.empty:
        sot = shooting_stats_df.loc[matching_index_shooting, ('Standard', 'SoT%')].values[0]
        premier_league_data.at[index, 'Sot%'] = sot

    if not matching_index_possession.empty:
        touches = possession_stats_df.loc[matching_index_possession, ('Touches', 'Touches')].values[0]
        def_touch = possession_stats_df.loc[matching_index_possession, ('Touches', 'Def Pen')].values[0] + possession_stats_df.loc[matching_index_possession, ('Touches', 'Def 3rd')].values[0]
        mid_touch = possession_stats_df.loc[matching_index_possession, ('Touches', 'Mid 3rd')].values[0]
        att_touch = possession_stats_df.loc[matching_index_possession, ('Touches', 'Att 3rd')].values[0] + possession_stats_df.loc[matching_index_possession, ('Touches', 'Att Pen')].values[0]
        premier_league_data.at[index, 'Touches'] = touches
        premier_league_data.at[index, 'Def Touch'] = def_touch
        premier_league_data.at[index, 'Mid Touch'] = mid_touch
        premier_league_data.at[index, 'Att Touch'] = att_touch

    if not matching_index_passing.empty:
        pass_short = passing_stats_df.loc[matching_index_passing, ('Short', 'Cmp%')].values[0]
        pass_med = passing_stats_df.loc[matching_index_passing, ('Medium', 'Cmp%')].values[0]
        pass_long = passing_stats_df.loc[matching_index_passing, ('Long', 'Cmp%')].values[0]
        premier_league_data.at[index, 'Short Pass'] = pass_short
        premier_league_data.at[index, 'Medium Pass'] = pass_med
        premier_league_data.at[index, 'Long Pass'] = pass_long

    if not matching_index_goalkeeping.empty:
        save = goalkeeping_stats_df.loc[matching_index_goalkeeping, ('Performance', 'Save%')].values[0]
        premier_league_data.at[index, 'Save%'] = save

premier_league_data = premier_league_data.drop(columns="Touches")
premier_league_data.to_csv('premier_league_data.csv', index=False)
print(premier_league_data)

premier_league_data = pd.read_csv('premier_league_data.csv')

# Calculate the correlation matrix
correlation_matrix = premier_league_data.corr()

# Create a heatmap using Seaborn
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('Correlation Heatmap')
plt.show()

premier_league_data["Date"] = pd.to_datetime(premier_league_data["Date"])
premier_league_data["opp"] = premier_league_data["Opponent"].astype("category").cat.codes
premier_league_data["ref"] = premier_league_data["Referee"].astype("category").cat.codes

premier_league_data['Outcome'] = premier_league_data['ScoreDiff'].apply(lambda x: 1 if x > 0 else (0 if x == 0 else -1))
premier_league_data["Ven"] = premier_league_data["Venue"].astype("category").cat.codes

print(premier_league_data)

# Summary Statistics Table with Match Counts
summary_stats = chelsea_data.groupby('Team').agg({'GF': ['mean', 'count'], 'GA': ['mean'], 'Poss': ['mean'], 'Sot%': ['mean'], 'Outcome': 'mean'})
print("Summary Statistics Table:")
print(summary_stats)

# Opponent Analysis Table with Match Counts
opponent_analysis = chelsea_data.groupby('Opponent').agg({'GF': ['mean', 'count'], 'GA': ['mean'], 'Poss': ['mean'], 'Sot%': ['mean'], 'Outcome': 'mean'})
print("\nOpponent Analysis Table:")
print(opponent_analysis)

# Home vs. Away Analysis Table with Match Counts
venue_analysis = chelsea_data.groupby('Venue').agg({'GF': ['mean', 'count'], 'GA': ['mean'], 'Poss': ['mean'], 'Sot%': ['mean'], 'Outcome': 'mean'})
print("\nHome vs. Away Analysis Table:")
print(venue_analysis)

# Formation Analysis Table with Match Counts (assuming 'Formation' column exists)
formation_analysis = chelsea_data.groupby('Formation').agg({'GF': ['mean', 'count'], 'GA': ['mean'], 'Poss': ['mean'], 'Sot%': ['mean'], 'Outcome': 'mean'})
print("\nFormation Analysis Table:")
print(formation_analysis)

# Captain Impact Table with Match Counts (assuming 'Captain' column exists)
captain_analysis = chelsea_data.groupby('Captain').agg({'GF': ['mean', 'count'], 'GA': ['mean'], 'Poss': ['mean'], 'Sot%': ['mean'], 'Outcome': 'mean'})
print("\nCaptain Impact Table:")
print(captain_analysis)

# Referee Analysis Table with Match Counts (assuming 'Referee' column exists)
referee_analysis = chelsea_data.groupby('Referee').agg({'GF': ['mean', 'count'], 'GA': ['mean'], 'Poss': ['mean'], 'Sot%': ['mean'], 'Outcome': 'mean'})
print("\nReferee Analysis Table:")
print(referee_analysis)

X = premier_league_data.drop(["Captain", 'Date', 'Team', 'Opponent', 'Venue', "Formation", "Referee"], axis=1)
X = X.dropna()
y = X['Outcome']

# Drop the 'Outcome' column from X
X = X.drop('Outcome', axis=1)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scale the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Initialize and train an MLP classifier
clf = MLPClassifier(hidden_layer_sizes=(100, 50), max_iter=1000, random_state=42)
clf.fit(X_train_scaled, y_train)

# Make predictions on the testing set
y_pred = clf.predict(X_test_scaled)

# Evaluate the model
accuracy = clf.score(X_test_scaled, y_test)
print("Accuracy:", accuracy)

# Create a DataFrame to display actual and predicted outcomes
results_df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})

# Display the DataFrame
print("\nActual and Predicted Outcomes:")
print(results_df)

from sklearn.metrics import confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# Compute confusion matrix
cm = confusion_matrix(y_test, y_pred)

# Plot confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Win', 'Draw', 'Lose'], yticklabels=['Win', 'Draw', 'Lose'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()